% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/expect_inform_fun.R
\name{computeInfo}
\alias{computeInfo}
\title{Compute Information matrix of a heteroscedastic model object (of class \code{hetCalibrate})}
\usage{
computeInfo(object)
}
\arguments{
\item{object}{an object of class \code{hetCalibrate}; e.g., as returned by \code{\link[HetCalibrate]{mleHetCalibrate}} with \code{orthogonal=TRUE}}
}
\value{
a matrix which contains the information matrix of all the parameters. The order of the parameters is \code{cpara}, \code{theta},  \code{nu_hat}, \code{theta_g}, \code{g}, \code{nu_hat_var}, \code{Delta}
}
\description{
Compute Information matrix of a heteroscedastic model object (of class \code{hetCalibrate})
}
\examples{
##------------------------------------------------------------
## Model calibration under heteroscedastic noises:
##    model discrepancy is modeled by an orthogonal Gaussian process
##------------------------------------------------------------
library(HetCalibrate)
set.seed(1)

##### setting #####
# computer model
f.sim <- function(x, cpara) {
 return(c(exp(x/10)*sin(x) - sqrt(cpara^2 - cpara + 1) * (sin(cpara*x)+cos(cpara*x))))
}
df.sim <- function(x, cpara) {
 return(c(-sqrt(cpara^2-cpara+1)*(x*cos(x*cpara)-x*sin(x*cpara))-((2*cpara-1)*(sin(x*cpara)+cos(x*cpara)))/(2*sqrt(cpara^2-cpara+1))))
}

# variance process - constant variance
var.f <- function(x) (0.01+0.2*(x-pi)^2)^2

# physical process
p.fun <- function(x) exp(x/10)*sin(x)

# true parameter
true.cpara <- optim(0, fn = function(g) {
 x.grid <- seq(0,2*pi,0.01)
 mean((p.fun(x.grid) - f.sim(x.grid, g))^2)
},
lower = -0.3, upper = 0.3, method = "L-BFGS-B")$par


# observed input
X0 <- seq(0,2*pi, length.out = 8)
# mean process
pmean <- p.fun(X0)
# variance process
var.y <- var.f(X0)
# number of replicates
n.rep <- rep(5, length(X0))

# setting for lower and upper bounds of parameters
cpara_min <- -0.3
cpara_max <- 0.3
cpara_init.vt <- c(-0.2, 0, 0.2)

# simulate X and Z
X <- matrix(rep(X0, n.rep), ncol = 1)
Z <- rep(0, sum(n.rep))
for(i in 1:length(X0)) {
 Z[(ifelse(i==1,0,sum(n.rep[1:(i-1)]))+1):sum(n.rep[1:i])] <- pmean[i] + rnorm(n.rep[i], 0, sd = sqrt(var.y[i]))
}

model <- mleHetCalibrate(X = X, Z = Z, cpara_max = cpara_max, cpara_min = cpara_min,
                        lower = 0.01*max(X0), upper = 2.5*max(X0),
                        init = list("cpara" = 0),
                        settings = list(checkHom = FALSE, linkThetas = "none"),
                        covtype = "Matern5_2", orthogonal = TRUE, f.sim = f.sim, df.sim = df.sim)

print(cpara.Het.OGP <- model$cpara)
Info.mx <- computeInfo(model)
# standard error of calibration parameter estimator
sd.cpara <- sqrt(diag(Info.mx)[1])
print(LCL <- qnorm(0.025, cpara.Het.OGP, sd.cpara)) # lower bound
print(UCL <- qnorm(0.975, cpara.Het.OGP, sd.cpara)) # upper bound
}
