% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hetCalibrate.R
\name{mleHetCalibrate}
\alias{mleHetCalibrate}
\title{Calibration of inexact computer models under heteroscedastic noise based on maximum likelihood estimation}
\usage{
mleHetCalibrate(
  X,
  Z,
  cpara_max = NULL,
  cpara_min = NULL,
  lower = NULL,
  upper = NULL,
  noiseControl = list(k_theta_g_bounds = c(1, 100), g_max = 100, g_bounds = c(1e-06, 1)),
  settings = list(linkThetas = "joint", logN = TRUE, initStrategy = "residuals",
    checkHom = TRUE, penalty = TRUE, trace = 0, return.matrices = TRUE, return.hom =
    FALSE),
  covtype = c("Gaussian", "Matern5_2", "Matern3_2"),
  maxit = 100,
  known = NULL,
  init = NULL,
  eps = sqrt(.Machine$double.eps),
  orthogonal = FALSE,
  f.sim,
  df.sim = NULL,
  MC.num = NULL,
  inputBounds = NULL
)
}
\arguments{
\item{X}{matrix of all designs, one per row, or list with elements:
\itemize{
  \item \code{X0} matrix of unique design locations, one point per row
  \item \code{Z0} vector of averaged observations, of length \code{nrow(X0)}
  \item \code{mult} number of replicates at designs in \code{X0}, of length \code{nrow(X0)}
}}

\item{Z}{vector of all observations. If using a list with \code{X}, \code{Z} has to be ordered with respect to \code{X0}, and of length \code{sum(mult)}}

\item{cpara_max, cpara_min}{upper bound and lower bound of the calibration parameter(s).}

\item{lower, upper}{optional bounds for the \code{theta} parameter (see \code{\link[hetGP]{cov_gen}} for the exact parameterization).
In the multivariate case, it is possible to give vectors for bounds (resp. scalars) for anisotropy (resp. isotropy)}

\item{noiseControl}{list with elements related to optimization of the noise process parameters:
\itemize{
\item \code{g_min}, \code{g_max} minimal and maximal noise to signal ratio (of the mean process)
\item \code{lowerDelta}, \code{upperDelta} optional vectors (or scalars) of bounds on \code{Delta}, of length \code{nrow(X0)} (default to \code{rep(eps, nrow(X0))} and \code{rep(noiseControl$g_max, nrow(X0))} resp., or their \code{log})
\item \code{lowerTheta_g}, \code{upperTheta_g} optional vectors of bounds for the lengthscales of the noise process if \code{linkThetas == 'none'}.
Same as for \code{theta} if not provided.
\item \code{k_theta_g_bounds} if \code{linkThetas == 'joint'}, vector with minimal and maximal values for \code{k_theta_g} (default to \code{c(1, 100)}). See Details.
\item \code{g_bounds} vector for minimal and maximal noise to signal ratios for the noise of the noise process, i.e., the smoothing parameter for the noise process.
(default to \code{c(1e-6, 1)}).
}}

\item{settings}{list for options about the general modeling procedure, with elements:
\itemize{
  \item \code{linkThetas} defines the relation between lengthscales of the mean and noise processes.
  Either \code{'none'}, \code{'joint'}(default) or \code{'constr'}, see Details.
  \item \code{logN}, when \code{TRUE} (default), the log-noise process is modeled.
  \item \code{initStrategy} one of \code{'simple'}, \code{'residuals'} (default) and \code{'smoothed'} to obtain starting values for \code{Delta}, see Details
  \item \code{penalty} when \code{TRUE}, the penalized version of the likelihood is used (i.e., the sum of the log-likelihoods of the mean and variance processes, see References).
  \item \code{checkHom} when \code{TRUE}, if the log-likelihood with a homoskedastic model is better, then return it.
  \item \code{trace} optional scalar (default to \code{0}). If positive, tracing information on the fitting process.
If \code{1}, information is given about the result of the heterogeneous model optimization.
Level \code{2} gives more details. Level {3} additionaly displays all details about initialization of hyperparameters.
\item \code{return.matrices} boolean to include the inverse covariance matrix in the object for further use (e.g., prediction).
\item \code{return.hom} boolean to include homoskedastic GP models used for initialization (i.e., \code{modHom} and \code{modNugs}).
}}

\item{covtype}{covariance kernel type, either \code{'Gaussian'}, \code{'Matern5_2'} or \code{'Matern3_2'}, see \code{\link[hetGP]{cov_gen}}}

\item{maxit}{maximum number of iterations for \code{L-BFGS-B} of \code{\link[stats]{optim}} dedicated to maximum likelihood optimization}

\item{init, known}{optional lists of starting values for mle optimization or that should not be optimized over, respectively.
Values in \code{known} are not modified, while it can happen to these of \code{init}, see Details.
One can set one or several of the following:
\itemize{
\item \code{theta} lengthscale parameter(s) for the mean process either one value (isotropic) or a vector (anistropic)
\item \code{Delta} vector of nuggets corresponding to each design in \code{X0}, that are smoothed to give \code{Lambda}
(as the global covariance matrix depend on \code{Delta} and \code{nu_hat}, it is recommended to also pass values for \code{theta})
\item \code{beta0} constant trend of the mean process
\item \code{k_theta_g} constant used for link mean and noise processes lengthscales, when \code{settings$linkThetas == 'joint'}
\item \code{theta_g} either one value (isotropic) or a vector (anistropic) for lengthscale parameter(s) of the noise process, when \code{settings$linkThetas != 'joint'}
\item \code{g} scalar nugget of the noise process
\item \code{g_H} scalar homoskedastic nugget for the initialisation with a \code{\link[hetGP]{mleHomGP}}. See Details.
\item \code{cpara} either a scalar or a vector for the calibration parameter(s) to be optimized over (default to the average of \code{cpara_max} and \code{cpara_min})
\item pX matrix of fixed pseudo inputs locations of the noise process corresponding to Delta
}}

\item{eps}{jitter used in the inversion of the covariance matrix for numerical stability}

\item{orthogonal}{logical. If \code{TRUE}, an orthogonal Gaussian process will be used to model the model discrepancy, otherwise a standard Gaussian process will be used.}

\item{f.sim}{a function indicating a computer model, where the input should include both input variables, \code{X}, and calibration parameter(s), \code{cpara}.}

\item{df.sim}{a function indicating the gradient of \code{f.sim}. The default is \code{NULL}, which approximates the gradient numerically by \code{\link[rootSolve]{gradient}}}

\item{MC.num}{a number indicating how many monte carlo samples are used to approximate a orthogonal kernel. . This is only effective when \code{orthogonal=TRUE}. The default is \code{NULL} which uses the rule of 30*\code{ncol(X)}.}

\item{inputBounds}{optional matrix of known boundaries in original input space, of size 2 times \code{ncol(X)}. This is only effective when \code{orthogonal=TRUE}. The default is \code{NULL} which uses the maximum and minimum values of \code{X}.}
}
\value{
a list which is given the S3 class \code{"hetCalbrate"}, with elements:
\itemize{
\item \code{theta}: unless given, maximum likelihood estimate (mle) of the lengthscale parameter(s),
\item \code{Delta}: unless given, mle of the nugget vector (non-smoothed),
\item \code{Lambda}: predicted input noise variance at \code{X0},
\item \code{nu_hat}: plugin estimator of the variance,
\item \code{theta_g}: unless given, mle of the lengthscale(s) of the noise/log-noise process,
\item \code{k_theta_g}: if \code{settings$linkThetas == 'joint'}, mle for the constant by which lengthscale parameters of \code{theta} are multiplied to get \code{theta_g},
\item \code{g}: unless given, mle of the nugget of the noise/log-noise process,
\item \code{trendtype}: either "\code{SK}" if \code{beta0} is provided, else "\code{OK}",
\item \code{beta0} constant trend of the mean process, plugin-estimator unless given,
\item \code{nmean}: plugin estimator for the constant noise/log-noise process mean,
\item \code{pX}: if used, matrix of pseudo-inputs locations for the noise/log-noise process,
\item \code{ll}: log-likelihood value, (\code{ll_non_pen}) is the value without the penalty,
\item \code{nit_opt}, \code{msg}: \code{counts} and \code{message} returned by \code{\link[stats]{optim}}
\item \code{modHom}: homoskedastic GP model of class \code{homGP} used for initialization of the mean process,
\item \code{modNugs}: homoskedastic GP model of class \code{homGP} used for initialization of the noise/log-noise process,
\item \code{nu_hat_var}: variance of the noise process,
\item \code{used_args}: list with arguments provided in the call to the function, which is saved in \code{call},
\item \code{Ki}, \code{Kgi}: inverse of the covariance matrices of the mean and noise processes (not scaled by \code{nu_hat} and \code{nu_hat_var}),
\item \code{X0}, \code{Z0}, \code{Z}, \code{eps}, \code{logN}, \code{covtype}: values given in input,
\item \code{time}: time to train the model, in seconds.
\item \code{cpara} maximum likelihood estimate of the calibration parameter(s)
\item \code{orthogonal} \code{orthogonal}
\item \code{f.sim} \code{f.sim}
\item \code{df.sim} \code{df.sim}
\item \code{MC.num} \code{MC.num}
\item \code{inputBounds} \code{inputBounds}
}
}
\description{
Calibration of inexact computer models under heteroscedastic noise based on maximum likelihood estimation.
}
\details{
This code performs model calibration for inexact computer model under heteroscedastic noise with multiple replicates. This code is modified from the source code of \code{\link[hetGP]{mleHetGP}}. We refer more details of the function to \code{\link[hetGP]{mleHetGP}}.
}
\examples{
##------------------------------------------------------------
## Model calibration under heteroscedastic noises:
##    model discrepancy is modeled by a standard Gaussian process
##------------------------------------------------------------
library(HetCalibrate)
set.seed(1)

##### setting #####
# computer model
f.sim <- function(x, cpara) {
 return(c(exp(x/10)*sin(x) - sqrt(cpara^2 - cpara + 1) * (sin(cpara*x)+cos(cpara*x))))
}
df.sim <- function(x, cpara) {
 return(c(-sqrt(cpara^2-cpara+1)*(x*cos(x*cpara)-x*sin(x*cpara))-((2*cpara-1)*(sin(x*cpara)+cos(x*cpara)))/(2*sqrt(cpara^2-cpara+1))))
}

# variance process - constant variance
var.f <- function(x) (0.01+0.2*(x-pi)^2)^2

# physical process
p.fun <- function(x) exp(x/10)*sin(x)

# true parameter
true.cpara <- optim(0, fn = function(g) {
 x.grid <- seq(0,2*pi,0.01)
 mean((p.fun(x.grid) - f.sim(x.grid, g))^2)
},
lower = -0.3, upper = 0.3, method = "L-BFGS-B")$par


# observed input
X0 <- seq(0,2*pi, length.out = 8)
# mean process
pmean <- p.fun(X0)
# variance process
var.y <- var.f(X0)
# number of replicates
n.rep <- rep(5, length(X0))

# setting for lower and upper bounds of parameters
cpara_min <- -0.3
cpara_max <- 0.3
cpara_init.vt <- c(-0.2, 0, 0.2)

# simulate X and Z
X <- matrix(rep(X0, n.rep), ncol = 1)
Z <- rep(0, sum(n.rep))
for(i in 1:length(X0)) {
 Z[(ifelse(i==1,0,sum(n.rep[1:(i-1)]))+1):sum(n.rep[1:i])] <- pmean[i] + rnorm(n.rep[i], 0, sd = sqrt(var.y[i]))
}

model <- mleHetCalibrate(X = X, Z = Z, cpara_max = cpara_max, cpara_min = cpara_min,
                        lower = 0.01*max(X0), upper = 2.5*max(X0),
                        init = list("cpara" = 0),
                        settings = list(checkHom = FALSE, linkThetas = "none"),
                        covtype = "Matern5_2", orthogonal = FALSE, f.sim = f.sim, df.sim = df.sim)

print(cpara.Het <- model$cpara)
xgrid <- matrix(seq(min(X0), max(X0), length.out = 101), ncol = 1)
predictions.Het <- predict(x = xgrid, object =  model)

plot(X, Z, ylab = 'y', xlab = "x")
Z0 <- hetGP::find_reps(X, Z)$Z0
points(X0, Z0, pch = 20, cex = 1.2)
lines(xgrid, predictions.Het$mean, col = 'red', lwd = 2)
curve(p.fun, min(X0), max(X0), add = TRUE, col = 1, lty = 2, lwd = 1)
lines(xgrid, qnorm(0.025, predictions.Het$mean, sqrt(predictions.Het$sd2 + predictions.Het$nugs)),
       col = 3, lty = 3, lwd = 2)
lines(xgrid, qnorm(0.975, predictions.Het$mean, sqrt(predictions.Het$sd2 + predictions.Het$nugs)),
       col = 3, lty = 3, lwd = 2)
lines(xgrid, f.sim(xgrid, cpara.Het), col = 4, lty = 2, lwd = 2)

##------------------------------------------------------------
## Model calibration under heteroscedastic noises:
##    model discrepancy is modeled by an orthogonal Gaussian process
##------------------------------------------------------------

model <- mleHetCalibrate(X = X, Z = Z, cpara_max = cpara_max, cpara_min = cpara_min,
                        lower = 0.01*max(X0), upper = 2.5*max(X0),
                        init = list("cpara" = 0),
                        settings = list(checkHom = FALSE, linkThetas = "none"),
                        covtype = "Matern5_2", orthogonal = TRUE, f.sim = f.sim, df.sim = df.sim)

print(cpara.Het.OGP <- model$cpara)
xgrid <- matrix(seq(min(X0), max(X0), length.out = 101), ncol = 1)
predictions.Het <- predict(x = xgrid, object =  model)

plot(X, Z, ylab = 'y', xlab = "x")
Z0 <- hetGP::find_reps(X, Z)$Z0
points(X0, Z0, pch = 20, cex = 1.2)
lines(xgrid, predictions.Het$mean, col = 'red', lwd = 2)
curve(p.fun, min(X0), max(X0), add = TRUE, col = 1, lty = 2, lwd = 1)
lines(xgrid, qnorm(0.025, predictions.Het$mean, sqrt(predictions.Het$sd2 + predictions.Het$nugs)),
     col = 3, lty = 3, lwd = 2)
lines(xgrid, qnorm(0.975, predictions.Het$mean, sqrt(predictions.Het$sd2 + predictions.Het$nugs)),
     col = 3, lty = 3, lwd = 2)
lines(xgrid, f.sim(xgrid, cpara.Het.OGP), col = 4, lty = 2, lwd = 2)
}
\references{
M. Binois, Robert B. Gramacy, M. Ludkovski (2018), Practical heteroskedastic Gaussian process modeling for large simulation experiments,
Journal of Computational and Graphical Statistics, 27(4), 808--821.\cr
Preprint available on arXiv:1611.05902. \cr \cr
}
\seealso{
\code{\link[HetCalibrate]{predict.hetCalibrate}} for predictions.
}
