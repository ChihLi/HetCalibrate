% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hetCalibrate.R
\name{mleHomCalibrate}
\alias{mleHomCalibrate}
\title{Calibration of inexact computer models under homoskedastic noise based on maximum likelihood estimation.}
\usage{
mleHomCalibrate(
  X,
  Z,
  cpara_max = NULL,
  cpara_min = NULL,
  lower = NULL,
  upper = NULL,
  known = NULL,
  noiseControl = list(g_bounds = c(sqrt(.Machine$double.eps), 100)),
  init = NULL,
  covtype = c("Gaussian", "Matern5_2", "Matern3_2"),
  maxit = 100,
  eps = sqrt(.Machine$double.eps),
  settings = list(return.Ki = TRUE),
  orthogonal = FALSE,
  f.sim,
  df.sim = NULL,
  MC.num = NULL,
  inputBounds = NULL
)
}
\arguments{
\item{X}{matrix of all designs, one per row, or list with elements:
\itemize{
  \item \code{X0} matrix of unique design locations, one point per row
  \item \code{Z0} vector of averaged observations, of length \code{nrow(X0)}
  \item \code{mult} number of replicates at designs in \code{X0}, of length \code{nrow(X0)}
}}

\item{Z}{vector of all observations. If using a list with \code{X}, \code{Z} has to be ordered with respect to \code{X0}, and of length \code{sum(mult)}}

\item{cpara_max, cpara_min}{upper bound and lower bound of the calibration parameter(s).}

\item{lower, upper}{optional bounds for the \code{theta} parameter (see \code{\link[hetGP]{cov_gen}} for the exact parameterization).
In the multivariate case, it is possible to give vectors for bounds (resp. scalars) for anisotropy (resp. isotropy)}

\item{known}{optional list of known parameters, e.g., \code{theta} or \code{g}}

\item{noiseControl}{list with element ,
\itemize{
\item \code{g_bounds}, vector providing minimal and maximal noise to signal ratio
}}

\item{init}{optional list specifying starting values for MLE optimization, with elements:
\itemize{
 \item \code{theta_init} initial value of the theta parameters to be optimized over (default to 10\% of the range determined with \code{lower} and \code{upper})
 \item \code{g_init} initial value of the nugget parameter to be optimized over (based on the variance at replicates if there are any, else \code{0.1})
 \item \code{cpara} initial value of the calibration parameter to be optimized over (default to the average of \code{cpara_max} and \code{cpara_min})
}}

\item{covtype}{covariance kernel type, either 'Gaussian', 'Matern5_2' or 'Matern3_2', see \code{\link[hetGP]{cov_gen}}}

\item{maxit}{maximum number of iteration for L-BFGS-B of \code{\link[stats]{optim}}}

\item{eps}{jitter used in the inversion of the covariance matrix for numerical stability}

\item{settings}{list with argument \code{return.Ki}, to include the inverse covariance matrix in the object for further use (e.g., prediction).}

\item{orthogonal}{logical. If \code{TRUE}, an orthogonal Gaussian process will be used to model the model discrepancy, otherwise a standard Gaussian process will be used.}

\item{f.sim}{a function indicating a computer model, where the input should include both input variables, \code{X}, and calibration parameter(s), \code{cpara}.}

\item{df.sim}{a function indicating the gradient of \code{f.sim}. The default is \code{NULL}, which approximates the gradient numerically by \code{\link[rootSolve]{gradient}}}

\item{MC.num}{a number indicating how many monte carlo samples are used to approximate a orthogonal kernel. . This is only effective when \code{orthogonal=TRUE}. The default is \code{NULL} which uses the rule of 30*\code{ncol(X)}.}

\item{inputBounds}{optional matrix of known boundaries in original input space, of size 2 times \code{ncol(X)}. This is only effective when \code{orthogonal=TRUE}. The default is \code{NULL} which uses the maximum and minimum values of \code{X}.}
}
\value{
a list which is given the S3 class "\code{HomCalibrate}", with elements:
\itemize{
\item \code{theta}: maximum likelihood estimate of the lengthscale parameter(s),
\item \code{g}: maximum likelihood estimate of the nugget variance,
\item \code{trendtype}: either "\code{SK}" if \code{beta0} is given, else "\code{OK}"
\item \code{beta0}: estimated trend unless given in input,
\item \code{nu_hat}: plugin estimator of the variance,
\item \code{ll}: log-likelihood value,
\item \code{X0}, \code{Z0}, \code{Z}, \code{mult}, \code{eps}, \code{covtype}: values given in input,
\item \code{call}: user call of the function
\item \code{used_args}: list with arguments provided in the call
\item \code{nit_opt}, \code{msg}: \code{counts} and \code{msg} returned by \code{\link[stats]{optim}}
\item \code{Ki}: inverse covariance matrix (not scaled by \code{nu_hat}) (if \code{return.Ki} is \code{TRUE} in \code{settings})
\item \code{time}: time to train the model, in seconds.
\item \code{cpara} maximum likelihood estimate of the calibration parameter(s)
\item \code{orthogonal} \code{orthogonal}
\item \code{f.sim} \code{f.sim}
\item \code{df.sim} \code{df.sim}
\item \code{MC.num} \code{MC.num}
\item \code{inputBounds} \code{inputBounds}

}
}
\description{
Calibration of inexact computer models under homoskedastic noise based on maximum likelihood estimation
}
\details{
This code performs model calibration for inexact computer model under homoskedastic noise with multiple replicates. This code is modified from the source code of \code{\link[hetGP]{mleHomGP}}. We refer more details of the function to \code{\link[hetGP]{mleHomGP}}.
}
\examples{
##------------------------------------------------------------
## Model calibration under homoskedastic noises:
##    model discrepancy is modeled by a standard Gaussian process
##------------------------------------------------------------

library(HetCalibrate)
set.seed(1)

##### setting #####
# computer model
f.sim <- function(x, cpara) {
 return(c(exp(x/10)*sin(x) - sqrt(cpara^2 - cpara + 1) * (sin(cpara*x)+cos(cpara*x))))
}
df.sim <- function(x, cpara) {
 return(c(-sqrt(cpara^2-cpara+1)*(x*cos(x*cpara)-x*sin(x*cpara))-((2*cpara-1)*(sin(x*cpara)+cos(x*cpara)))/(2*sqrt(cpara^2-cpara+1))))
}

# variance process - constant variance
var.f <- function(x) return(rep(0.5, length(x)))

# physical process
p.fun <- function(x) exp(x/10)*sin(x)

# true parameter
true.cpara <- optim(0, fn = function(g) {
 x.grid <- seq(0,2*pi,0.01)
 mean((p.fun(x.grid) - f.sim(x.grid, g))^2)
},
lower = -0.3, upper = 0.3, method = "L-BFGS-B")$par


# observed input
X0 <- seq(0,2*pi, length.out = 8)
# mean process
pmean <- p.fun(X0)
# variance process
var.y <- var.f(X0)
# number of replicates
n.rep <- rep(5, length(X0))

# setting for lower and upper bounds of parameters
cpara_min <- -0.3
cpara_max <- 0.3
cpara_init.vt <- c(-0.2, 0, 0.2)

# simulate X and Z
X <- matrix(rep(X0, n.rep), ncol = 1)
Z <- rep(0, sum(n.rep))
for(i in 1:length(X0)) {
 Z[(ifelse(i==1,0,sum(n.rep[1:(i-1)]))+1):sum(n.rep[1:i])] <- pmean[i] + rnorm(n.rep[i], 0, sd = sqrt(var.y[i]))
}

model <- mleHomCalibrate(X = X, Z = Z, cpara_max = cpara_max, cpara_min = cpara_min,
                        lower = 0.01*max(X0), upper = 2.5*max(X0),
                        init = list("cpara" = 0),
                        covtype = "Matern5_2", orthogonal = FALSE, f.sim = f.sim, df.sim = df.sim)

print(cpara.Hom <- model$cpara)
xgrid <- matrix(seq(min(X0), max(X0), length.out = 101), ncol = 1)
predictions.Hom <- predict(x = xgrid, object =  model)

plot(X, Z, ylab = 'y', xlab = "x")
Z0 <- hetGP::find_reps(X, Z)$Z0
points(X0, Z0, pch = 20, cex = 1.2)
lines(xgrid, predictions.Hom$mean, col = 'red', lwd = 2)
curve(p.fun, min(X0), max(X0), add = TRUE, col = 1, lty = 2, lwd = 1)
lines(xgrid, qnorm(0.025, predictions.Hom$mean, sqrt(predictions.Hom$sd2 + predictions.Hom$nugs)),
       col = 3, lty = 3, lwd = 2)
lines(xgrid, qnorm(0.975, predictions.Hom$mean, sqrt(predictions.Hom$sd2 + predictions.Hom$nugs)),
       col = 3, lty = 3, lwd = 2)
lines(xgrid, f.sim(xgrid, cpara.Hom), col = 4, lty = 2, lwd = 2)

##------------------------------------------------------------
## Model calibration under homoskedastic noises:
##    model discrepancy is modeled by an orthogonal Gaussian process
##------------------------------------------------------------

model <- mleHomCalibrate(X = X, Z = Z, cpara_max = cpara_max, cpara_min = cpara_min,
                        lower = 0.01*max(X0), upper = 2.5*max(X0),
                        init = list("cpara" = 0),
                        covtype = "Matern5_2", orthogonal = TRUE, f.sim = f.sim, df.sim = df.sim)

print(cpara.Hom.OGP <- model$cpara)
xgrid <- matrix(seq(min(X0), max(X0), length.out = 101), ncol = 1)
predictions.Hom <- predict(x = xgrid, object =  model)

plot(X, Z, ylab = 'y', xlab = "x")
Z0 <- hetGP::find_reps(X, Z)$Z0
points(X0, Z0, pch = 20, cex = 1.2)
lines(xgrid, predictions.Hom$mean, col = 'red', lwd = 2)
curve(p.fun, min(X0), max(X0), add = TRUE, col = 1, lty = 2, lwd = 1)
lines(xgrid, qnorm(0.025, predictions.Hom$mean, sqrt(predictions.Hom$sd2 + predictions.Hom$nugs)),
     col = 3, lty = 3, lwd = 2)
lines(xgrid, qnorm(0.975, predictions.Hom$mean, sqrt(predictions.Hom$sd2 + predictions.Hom$nugs)),
     col = 3, lty = 3, lwd = 2)
lines(xgrid, f.sim(xgrid, cpara.Hom.OGP), col = 4, lty = 2, lwd = 2)
}
\references{
M. Binois, Robert B. Gramacy, M. Ludkovski (2018), Practical heteroskedastic Gaussian process modeling for large simulation experiments,
Journal of Computational and Graphical Statistics, 27(4), 808--821.\cr
Preprint available on arXiv:1611.05902. \cr \cr
}
\seealso{
\code{\link[HetCalibrate]{predict.homCalibrate}} for predictions.
}
